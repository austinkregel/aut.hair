<?php

declare(strict_types=1);

namespace App\Services\Programming;

use App\Services\Code;
use Nette\PhpGenerator\Dumper;
use Nette\PhpGenerator\Literal;
use Nette\PhpGenerator\PhpFile;
use Nette\PhpGenerator\PhpNamespace;
use Nette\PhpGenerator\Property;

class LaravelProgrammingStyle extends Code
{
    public function addListenerToEvent(string $eventName, string $listener)
    {
        // We need to find the event service provider
        // Then find the $listen property
        // then the index of the event
        // lastly add the listener to the array of listeners
        // and rebuild the file.
        $this->import([$listener, $eventName]);
        $this->modifyProperty('listen', function (Property $property) use ($eventName, $listener) {
            /** @var Literal $literal */
            $literal = $property->getValue();
            // plan: Split the literal into chunks, look for the $eventName,
            // When $eventName is found, on the following line insert $listener with a trailing comma.

            $lineWithEvent = null;
            $content = explode("\n", (string) $literal);

            if (count($content) <= 2) {
                throw new \DomainException('This EventServiceProvider needs to have at least 3 lines for the $listen');
            }

            $content = array_values(array_filter($content));

            foreach ($content as $lineNumber => $line) {
                if (str_contains($line, $eventName)) {
                    $lineWithEvent = $lineNumber;
                }
            }

            if ($lineWithEvent === null) {
                $content = array_merge(array_slice($content, 0, 1), [
                    // new line with our listener,
                    '    '.$this->formatClassWithClass($eventName).' => [',
                    '        '.$this->formatClassWithClass($listener).', // code: this is an autogenerated line',
                    '    ],',
                ], array_slice($content, 1, count($content)));
            } else {
                $content = array_merge(array_slice($content, 0, $lineWithEvent + 1), [
                    // new line with our listener,
                    '        '.$this->formatClassWithClass($listener).', // code: this is an autogenerated line',
                ], array_slice($content, $lineWithEvent + 1, count($content)));
            }

            $property->setValue((new Literal(implode("\n", $content))));
        });

        return $this;
    }

    public function propertyContainsValue(string $propertyName, string $valueToLookFor)
    {
        /** @var PhpFile $file */
        foreach ($this->phpFiles as $file) {
            /** @var PhpNamespace $namespaceObject */
            foreach ($file->getNamespaces() as $namespace => $namespaceObject) {
                // Add code at the namespace level like use statements, declare(strict_types=1);
                /** @var \Nette\PhpGenerator\ClassType $class */
                foreach ($file->getClasses() as $class) {
                    /** @var \Nette\PhpGenerator\Property $property */
                    foreach ($class->getProperties() as $definedProperty => $property) {
                        if ($definedProperty === $propertyName) {
                            /** @var Literal $value */
                            $value = $property->getValue();

                            if (is_string($value) && str_contains($value, $valueToLookFor)) {
                                return true;
                            }
                            $value = $value->formatWith(new Dumper);

                            if (str_contains($value, $valueToLookFor)) {
                                return true;
                            }
                        }
                    }
                }
            }
        }

        return false;
    }

    public function removeListenerFromEvent(string $eventName, string $listener)
    {
        // We need to find the event service provider
        // Then find the $listen property
        // then the index of the event
        // lastly add the listener to the array of listeners
        // and rebuild the file.
        $this->removeImport([$listener]);
        $this->modifyProperty('listen', function (Property $property) use ($eventName, $listener) {
            /** @var Literal $literal */
            $literal = $property->getValue();
            // plan: Split the literal into chunks, look for the $eventName,
            // When $eventName is found, on the following line insert $listener with a trailing comma.

            $lineWithListener = null;
            $content = explode("\n", (string) $literal);

            if (count($content) <= 2) {
                throw new \DomainException('This EventServiceProvider needs to have at least 3 lines for the $listen');
            }

            $content = array_values(($content));

            $lineWithEvent = null;
            $eventLineEnd = null;
            foreach ($content as $lineNumber => $line) {
                if ($lineWithEvent === null && str_contains($line, $eventName)) {
                    $lineWithEvent = $lineNumber;
                }

                if ($lineWithEvent !== null && $eventLineEnd === null && str_contains($line, $listener)) {
                    unset($content[$lineNumber]);
                    $lineWithListener = $lineNumber;
                }

                if ($eventLineEnd === null && $lineWithEvent !== null && $lineNumber > $lineWithEvent && str_contains($line, ']')) {
                    $eventLineEnd = $lineNumber;
                }

            }

            $property->setValue(new Literal(implode("\n", $content)));
        });

        return $this;
    }

    public function formatClassWithClass(string $class)
    {
        return '/*(n*/'.$class.'::class';
    }

    public function removeImport($fqns)
    {
        $imports = is_array($fqns) ? $fqns : func_get_args();
        foreach ($this->phpFiles as $phpFile) {
            /**
             * @var string $namespaceName
             * @var PhpNamespace $namespace
             */
            foreach ($phpFile->getNamespaces() as $namespaceName => $namespace) {
                foreach ($imports as $importToRemove) {
                    $uses = $namespace->getUses();
                    if (! in_array($importToRemove, $uses)) {
                        // not already imported;
                        continue;
                    }

                    $namespace->removeUse($importToRemove);
                }
            }
        }

        return $this;
    }

    public function renameClass(string $newClassName, ?string $newNamespace = null)
    {
        /** @var PhpFile $phpFile */
        foreach ($this->phpFiles as $filePath => $phpFile) {
            if (count($phpFile->getNamespaces()) > 1) {
                throw new \Exception('Too many namespaces in class file to rename: '.$filePath);
            }

            /**
             * @var string $namespaceName
             * @var PhpNamespace $namespace
             */
            foreach ($phpFile->getNamespaces() as $namespaceName => $namespace) {
                if (! empty($newNamespace)) {

                    $newNamespaceObject = new PhpNamespace($newNamespace);
                    foreach ($namespace->getUses() as $importAlias => $importedClass) {
                        $newNamespaceObject->addUse($importedClass, $importAlias);
                    }

                    foreach ($namespace->getClasses() as $class) {
                        $newNamespaceObject->add($class);
                    }
                    foreach ($namespace->getFunctions() as $function) {
                        $newNamespaceObject->add($function);
                    }

                    $file = new PhpFile;
                    $file->setStrictTypes($phpFile->hasStrictTypes());
                    $file->addNamespace($newNamespaceObject);

                    $this->phpFiles[$filePath] = $file;
                }

                $classes = $namespace->getClasses();

                if (count($classes) > 1) {
                    throw new \Exception('Too many classes in class file to rename: '.$filePath);
                }
                foreach ($classes as $class) {
                    $class->setName($newClassName);
                }
            }
        }

        return $this;
    }

    public function modifyConstructor(string $parameterToEdit, string $typeOfParameter, mixed $defaultValue = null, ?bool $nullable = false): static
    {
        foreach ($this->phpFiles as $phpFile) {
            /**
             * @var string $namespaceName
             * @var PhpNamespace $namespace
             */
            foreach ($phpFile->getNamespaces() as $namespaceName => $namespace) {
                $classes = $namespace->getClasses();
                foreach ($classes as $class) {
                    if (! $class->hasMethod('__construct')) {
                        // no constructor
                        $class->addMethod('__construct');
                    }

                    $constructor = $class->getMethod('__construct');

                    if (! $constructor->hasParameter($parameterToEdit)) {
                        $constructor->addParameter($parameterToEdit);
                    }

                    $parameter = $constructor->getParameter($parameterToEdit);

                    $parameter->setNullable($nullable);

                    $this->setValidType($parameter, $typeOfParameter);

                    if (empty($defaultValue) && $parameter->isNullable()) {
                        $parameter->setDefaultValue($defaultValue);
                    } elseif (! empty($defaultValue)) {
                        $parameter->setDefaultValue($defaultValue);
                    }
                }
            }

            return $this;
        }

        return $this;
    }

    public function modifyMethod(string $methodName, string $content, mixed $returnType = null, mixed $defaultValue = null, ?bool $nullable = false, ?array $parameters = []): static
    {
        foreach ($this->phpFiles as $phpFile) {
            /**
             * @var string $namespaceName
             * @var PhpNamespace $namespace
             */
            foreach ($phpFile->getNamespaces() as $namespaceName => $namespace) {
                $classes = $namespace->getClasses();
                foreach ($classes as $class) {
                    if (! $class->hasMethod($methodName)) {
                        // no constructor
                        $class->addMethod($methodName);
                    }

                    $method = $class->getMethod($methodName);

                    $method->setBody($content);
                    if (! empty($returnType)) {
                        $this->setValidType($method, $returnType);
                    }

                    if (! empty($parameters)) {
                        $method->setParameters($parameters);
                    }
                }
            }

            return $this;
        }

        return $this;
    }

    public function removeMethod(string $methodName): static
    {
        foreach ($this->phpFiles as $phpFile) {
            /**
             * @var string $namespaceName
             * @var PhpNamespace $namespace
             */
            foreach ($phpFile->getNamespaces() as $namespace) {
                $classes = $namespace->getClasses();
                foreach ($classes as $class) {
                    if ($class->hasMethod($methodName)) {
                        // no constructor
                        $class->removeMethod($methodName);
                    }
                }
            }

            return $this;
        }

        return $this;
    }

    protected function setValidType($parameter, $typeOfParameter)
    {
        if (in_array($typeOfParameter, ['int', 'integer', 'string', 'float', 'null'])) {
            $parameter->setType($typeOfParameter);
        } elseif (class_exists($typeOfParameter)) {
            $this->import($typeOfParameter);
            $parameter->setType($typeOfParameter);
        } else {
            // Intentionally ignoring classes that return false
        }

        return $parameter;
    }

    public function getMethod(string $methodName)
    {
        foreach ($this->phpFiles as $phpFile) {
            /**
             * @var string $namespaceName
             * @var PhpNamespace $namespace
             */
            foreach ($phpFile->getNamespaces() as $namespace) {
                $classes = $namespace->getClasses();
                foreach ($classes as $class) {
                    if ($class->hasMethod($methodName)) {
                        return $class->getMethod($methodName);
                    }
                }
            }
        }
    }
}
